#!/usr/bin/python

# Copyright (c) 2011, Nathan Wiegand <nathanwiegand@gmail.com>,
# Keir Mierle <mierle@gmail.com> All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.

__author__ = ['nathanwiegand@gmail.com', 'mierle@gmail.com']

import os
import re
import shutil
import subprocess
import sys
import tempfile
import urllib

try:
  import json
except:
  sys.path.append("third_party")
  import third_party.simplejson as json


def check_if_executable_exists(name):
    """Checks if an executable named 'name' is in the PATH.

    This is necessary because the 'which' command isn't universally portable.

    Args:
        name: String name of a binary, e.g. 'which'
    Returns:
        True if there is an executable with this name anywhere in the system
        PATH.
    """
    for p in os.getenv("PATH").split(os.pathsep):
        full_path = "%s/%s" % (p, name)

        if os.path.exists(full_path) and os.access(full_path, os.X_OK):
            return True
    return False

# TODO(nathanwiegand): Need to make it work with branches and commit numbers.

# TODO(nathanwiegand): Get rid of the extraneous output and print the URL
# prominentaly.


def get_fork_information(components):
    """Retrieves the JSON metadata about a project.

    The GitHub API allows us to retrieve meta-data about a particular user's
    project.  This function takes a dictionary, 'components', which must have
    project and user defined, corresponding to the GitHub username and the
    GitHub project name.

    Args:
        components: A dictionary which contains 'user' and 'project'
    Returns:
        A dict corresponding to the JSON metadata returned by GitHub for this
        project. An example of the meta data returned can be seen by calling
        get_fork_information({'user': 'vangogh', 'project':'vangogh'})
    """
    url = "https://github.com/api/v2/json/repos/show/%(user)s/%(project)s" \
          % components

    f = urllib.urlopen(url)
    if f.getcode() != 200:
        return {}
    response = json.loads(f.read())
    f.close()
    return response

def pull_from_head(repo_url, working_path):
    previous_dir = os.getcwd()
    os.chdir(working_path)

    command = "git clone --depth=1 %s" % repo_url
    process = subprocess.Popen(command.split(), stdout = sys.stdout,
                               stderr = sys.stdout)
    process.wait()
    os.chdir(previous_dir)

def read_url(url):
    """Return the contents of a URL.

    This is a simple helper function which downloads a URL, and if the HTTP
    status was OK (200) then it returns the contents of that URL. Otherwise it
    returns an empty string.

    Args:
        url: The URL to fetch
    Returns:
        String contents of the URL If the URL was fetched successfully or empty
        string otherwise.
    """
    # pull the new version
    f = urllib.urlopen(url)

    if f.getcode() != 200:
        return ""

    contents = f.read()
    f.close()
    return contents

def read_json_url(url):
    """Reads the contents of a URL and interprets the JSON response.

    Args:
        url: The URL to fetch
    Returns:
        Dictionary equivalent of the JSON contents of the URL
    """
    contents = read_url(url)
    if contents:
        return json.loads(contents)
    return {}

def parse_github_path(url):
    """Interprets a GitHub URL.

    GitHub URLs encode information about a branch in a human readable format.
    This function parses out that infomation and returns it in a dictionary.

    Args:
        url: The GitHub URL of the project, a branch, a commit, or a file.
    Returns:
        A dictionary which encodes infomration about the project. An example:
          {'host': 'github.com',
           'user': 'vangogh',
           'project': 'vangogh',
           'github_view_type': 'blob',
           'file': 'vangogh',
           'commit': 'master',
           'line': '',
           'type': 'file',
           'github_view_type': 'blob'
          }
    """
    components_regex = re.compile(
          "https://([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^#]+)#?(.*)$")

    components = components_regex.match(url)

    if components:
        return {
            'host': components.group(1),
            'user': components.group(2),
            'project': components.group(3),
            'github_view_type': components.group(4),
            'commit': components.group(5),
            'file': components.group(6),
            'line': components.group(7),
            'type': 'file'
        }
    components_regex = re.compile(
        "https://([^/]+)/([^/]+)/([^/]+)/([^/]+)/([^/]+)$")
    components = components_regex.match(url)

    if components:
        return {
            'host': components.group(1),
            'user': components.group(2),
            'project': components.group(3),
            'tree': components.group(4),
            'branch': components.group(5),
            'type': 'branch'
        }

    components_regex = re.compile( "https://([^/]+)/([^/]+)/([^/]+)$")
    components = components_regex.match(url)

    if components:
        return {
            'host': components.group(1),
            'user': components.group(2),
            'project': components.group(3),
            'type': 'repo'
        }

def make_github_url(components):
    """Constructs a GitHub URL to either a file or project.

    Given a dictionary of components that contains the fields 'user', 'host',
    and 'projects' (optionally 'commit' and 'file'), generate a GitHub URL.

    Args:
        components: A dictionary that must contain 'host', 'user', and
        'project'.
    Returns:
        String URL to a GitHub project or a GitHub file.
    """
    if components['type'] == 'file':
        return ("https://%(host)s/%(user)s/%(project)s/"
                "%(github_view_type)s/%(commit)s/%(file)s") % components
    else:
        return ("https://%(host)s/%(user)s/%(project)s/"
                "%(tree)s/%(branch)s") % components

def create_git_repo():
    """Creates a fresh Git repository in a temporary directory.

    Returns:
        String path to the new Git repository.
    """
    print "Creating a git repo"
    path = tempfile.mkdtemp()
    previous_cwd = os.getcwd()
    os.chdir(path)

    subprocess.call("git init".split())
    return path

def write_file_and_commit(name, contents):
    """Create a file with a specified name and contents, and then commit it to
    the repository.

    Args:
        name: The string file name of the new file
        contents: The string contents of the new file
    Returns:
        True on success
    """
    print "Writing a file of %d bytes" % len(contents)
    o = open(name, 'w')
    print >> o, contents
    o.close()

    print "Committing new file to repo"

    command = "git add %s" % name
    subprocess.call(command.split())
    command = "git commit -am 'review'"
    subprocess.call(command.split())
    return True

def create_subdirectories(components, path):
    """Creates subdirectories corresponding to the directory structure of the
    GitHub repository.

    Returns:
      Nothing
    """
    file_path = components["file"]
    dirs = os.path.dirname(file_path)

    # create the directory
    os.makedirs(dirs)
    os.chdir(path + "/" + dirs)

def pull_file_and_head_version(components, mainline_components, path):
    """Copies a file from two branches and commits them to the same repo.

    This copyies the 'original' file to the repo, followed by the 'new' file.
    Because of this, the diff between versions of this file will now correspond
    to the diff between the two versions: 'original' and 'new'.
    """
    print "Copying %s" % components["file"]
    url = make_github_url(components)

    file_path = components["file"]
    file_name = os.path.basename(file_path)

    # pull the new version
    contents = read_url(url)

    # pull the mainline version
    mainline_url = make_github_url(mainline_components)

    mainline_contents = read_url(mainline_url)

    write_file_and_commit(file_name, mainline_contents)
    write_file_and_commit(file_name, contents)

def upload_to_codereview(components, mainline_components):
    """Uploads the diffs to the Reitveld instance.

    Args:
        mainline_components: Dict containing the fields 'user' and 'project'
        which correspond to the mainline project's username and project.
    """

    # TODO(nathanwiegand): Change this so that first it checks to see if there's
    # a project wide file, and if not, it defaults to codereview.appspot.com
    command = ('git cl config https://github.com/%(user)s/%(project)s'
               '/raw/master/codereview.settings' % mainline_components)
    subprocess.call(command.split())

    reviewer_line = ""
    if "email" in components:
        reviewer_line = "-r %s" % components['email']

    command = 'git cl upload %s master' % reviewer_line
    subprocess.call(command.split())

def clean_up(path):
    """Delete the temporary directory specified by 'path'

    Args:
        path: String path to the temporary directory which will be deleted.
    """
    print "Deleting %s" % path
    shutil.rmtree(path)

def pull_branches(components, mainline_components):
    """Pulls two branches, one ontop of the other.

    This allows us to diff all files in one branch, 'components', with the
    another, 'original'.

    Args:
        components: Dict specifying the new branch. Must contain 'user' and
              'project'
        mainline_components: Dict specifying the original branch. Must contain
              'user' and 'project'
    """
    mainline_url = 'git@github.com:%(user)s/%(project)s.git' % \
        mainline_components

    url = 'git@github.com:%(user)s/%(project)s.git' % components
    print "Pulling from: " , mainline_url
    command = 'git pull %s master' % mainline_url
    subprocess.call(command.split())

    command = 'git checkout -b %s ' % components['user']
    subprocess.call(command.split())

    print "Pulling from: " , url
    command = 'git pull %s master' % url
    subprocess.call(command.split())

def get_user_information(components):
    user_info = read_json_url("https://api.github.com/users/%(user)s" %
                              components)
    return user_info

def main(argv):
    if len(argv) != 2:
        print >> sys.stderr, "usage: vangough <url>"
        return 1

    if not check_if_executable_exists('git-cl'):
        print >> sys.stderr, "ERROR: git-cl not in path."
        return 1

    if not check_if_executable_exists('upload.py'):
        print >> sys.stderr, "ERROR: upload.py not in path."
        return 1

    file_url = argv[1]
    components =  parse_github_path(file_url)

    fork_info = get_fork_information(components)
    mainline_components = components.copy()

    if 'repository' not in fork_info or 'parent' not in fork_info['repository']:
        print "vangogh only operates on projects which are forks."
        return 1
    user_project_regex = re.compile("([^/]+)/(.*)$")
    user_project = user_project_regex.match(
            fork_info['repository']['parent'])
    if not user_project:
        print "Couldn't parse response from github."
        return 1
    mainline_components['user'] = user_project.group(1)
    mainline_components['project'] = user_project.group(2)
    mainline_components['branch'] = 'master'

    user_info = get_user_information(components)
    mainline_user_info = get_user_information(components)

    if 'email' in user_info:
        components['email'] = user_info['email']

    if 'email' in mainline_user_info:
        mainline_components['email'] = mainline_user_info['email']

    repo_path = create_git_repo()

    if components['type'] == 'file':
        # Change the 'github_view_type' to 'raw' so that we get the raw file
        # instead of the github html marked up version.
        components['github_view_type'] = 'raw'
        create_subdirectories(components, repo_path)
        pull_file_and_head_version(components, mainline_components, repo_path)
        upload_to_codereview(components, mainline_components)
    elif components['type'] == 'branch' or components['type'] == 'repo':
        pull_branches(components, mainline_components)
        upload_to_codereview(components, mainline_components)
    clean_up(repo_path)

if __name__ == "__main__":
    sys.exit(main(sys.argv))
